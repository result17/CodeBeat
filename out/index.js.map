{"version":3,"sources":["../src/index.ts","../node_modules/@reactive-vscode/reactivity/dist/index.js","../node_modules/reactive-vscode/dist/index.js","../src/constants.ts","../src/events.ts","../src/utils.ts"],"sourcesContent":["import { defineExtension, useStatusBarItem } from 'reactive-vscode'\r\nimport { StatusBarAlignment } from 'vscode'\r\nimport { clockIconName } from './constants'\r\nimport { useOnEvent } from './events'\r\nimport { formatMilliseconds } from './utils'\r\n\r\nconst { activate, deactivate } = defineExtension(() => {\r\n  const statusBar = useStatusBarItem({\r\n    id: 'com.github.result17',\r\n    alignment: StatusBarAlignment.Left,\r\n    priority: 3,\r\n    text: clockIconName,\r\n  })\r\n\r\n  statusBar.show()\r\n\r\n  useOnEvent(({ duringMs }) => {\r\n    statusBar.text = `${clockIconName} ${formatMilliseconds(duringMs)}`\r\n  })\r\n})\r\n\r\nexport { activate, deactivate }\r\n","/**\n* @vue/shared v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\n!!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty$1.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\n/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction warn$1(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    this._active = true;\n    this.effects = [];\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn$1(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    this.deps = void 0;\n    this.depsTail = void 0;\n    this.flags = 1 | 4;\n    this.next = void 0;\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn$1(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed2) {\n  if (computed2.flags & 4 && !(computed2.flags & 16)) {\n    return;\n  }\n  computed2.flags &= ~16;\n  if (computed2.globalVersion === globalVersion) {\n    return;\n  }\n  computed2.globalVersion = globalVersion;\n  const dep = computed2.dep;\n  computed2.flags |= 2;\n  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {\n    computed2.flags &= ~2;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed2;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed2);\n    const value = computed2.fn(computed2._value);\n    if (dep.version === 0 || hasChanged(value, computed2._value)) {\n      computed2._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed2);\n    computed2.flags &= ~2;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn$1(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed2) {\n    this.computed = computed2;\n    this.version = 0;\n    this.activeLink = void 0;\n    this.subs = void 0;\n    this.map = void 0;\n    this.key = void 0;\n    this.sc = 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed2 = link.dep.computed;\n    if (computed2 && !link.dep.subs) {\n      computed2.flags |= 4 | 16;\n      for (let l = computed2.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn$1(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly2, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly2) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly2 && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly2) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;\n      !readonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly2 ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly2, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn$1(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn$1(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    this._value = void 0;\n    this.dep = new Dep(this);\n    this.__v_isRef = true;\n    this.deps = void 0;\n    this.depsTail = void 0;\n    this.flags = 16;\n    this.globalVersion = globalVersion - 1;\n    this.next = void 0;\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn$1(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch$1(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn$1)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect2;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect2;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect2.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect2);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect2.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect2;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect2.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect2 = new ReactiveEffect(getter);\n  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);\n  cleanup = effect2.onStop = () => {\n    const cleanups = cleanupMap.get(effect2);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect2);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect2.onTrack = options.onTrack;\n    effect2.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect2.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect2.run();\n  }\n  watchHandle.pause = effect2.pause.bind(effect2);\n  watchHandle.resume = effect2.resume.bind(effect2);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\nfunction warn(msg, ...args) {\n  pauseTracking();\n  const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n  console.warn(...warnArgs);\n  resetTracking();\n}\nvar LifecycleHooks = /* @__PURE__ */ ((LifecycleHooks2) => {\n  LifecycleHooks2[\"ACTIVATED\"] = \"a\";\n  LifecycleHooks2[\"DEACTIVATED\"] = \"da\";\n  return LifecycleHooks2;\n})(LifecycleHooks || {});\nvar ErrorCodes = /* @__PURE__ */ ((ErrorCodes2) => {\n  ErrorCodes2[ErrorCodes2[\"WATCH_GETTER\"] = 0] = \"WATCH_GETTER\";\n  ErrorCodes2[ErrorCodes2[\"WATCH_CALLBACK\"] = 1] = \"WATCH_CALLBACK\";\n  ErrorCodes2[ErrorCodes2[\"WATCH_CLEANUP\"] = 2] = \"WATCH_CLEANUP\";\n  ErrorCodes2[ErrorCodes2[\"APP_ERROR_HANDLER\"] = 3] = \"APP_ERROR_HANDLER\";\n  ErrorCodes2[ErrorCodes2[\"SCHEDULER\"] = 4] = \"SCHEDULER\";\n  return ErrorCodes2;\n})(ErrorCodes || {});\nconst ErrorTypeStrings = {\n  [LifecycleHooks.ACTIVATED]: \"activated hook\",\n  [LifecycleHooks.DEACTIVATED]: \"deactivated hook\",\n  [\n    0\n    /* WATCH_GETTER */\n  ]: \"watcher getter\",\n  [\n    1\n    /* WATCH_CALLBACK */\n  ]: \"watcher callback\",\n  [\n    2\n    /* WATCH_CLEANUP */\n  ]: \"watcher cleanup function\",\n  [\n    3\n    /* APP_ERROR_HANDLER */\n  ]: \"app errorHandler\",\n  [\n    4\n    /* SCHEDULER */\n  ]: \"scheduler flush\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  try {\n    return args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  if (isArray(fn)) {\n    const values = [];\n    for (let i = 0; i < fn.length; i++) {\n      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n    }\n    return values;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`\n    );\n  }\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = null;\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const info = ErrorTypeStrings[type];\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {\n    console.error(err);\n  }\n}\nvar SchedulerJobFlags = /* @__PURE__ */ ((SchedulerJobFlags2) => {\n  SchedulerJobFlags2[SchedulerJobFlags2[\"QUEUED\"] = 1] = \"QUEUED\";\n  SchedulerJobFlags2[SchedulerJobFlags2[\"PRE\"] = 2] = \"PRE\";\n  SchedulerJobFlags2[SchedulerJobFlags2[\"ALLOW_RECURSE\"] = 4] = \"ALLOW_RECURSE\";\n  SchedulerJobFlags2[SchedulerJobFlags2[\"DISPOSED\"] = 8] = \"DISPOSED\";\n  return SchedulerJobFlags2;\n})(SchedulerJobFlags || {});\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = isFlushing ? flushIndex + 1 : 0;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!(job.flags & 1)) {\n    const jobId = getId(job);\n    const lastJob = queue[queue.length - 1];\n    if (!lastJob || // fast path when the job id is larger than the tail\n    !(job.flags & 2) && jobId >= getId(lastJob)) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(jobId), 0, job);\n    }\n    job.flags |= 1;\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)].sort(\n      (a, b) => getId(a) - getId(b)\n    );\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      seen = seen || /* @__PURE__ */ new Map();\n    }\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      const cb = activePostFlushCbs[postFlushIndex];\n      if (!!(process.env.NODE_ENV !== \"production\") && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      if (cb.flags & 4) {\n        cb.flags &= ~1;\n      }\n      if (!(cb.flags & 8)) cb();\n      cb.flags &= ~1;\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  const check = !!(process.env.NODE_ENV !== \"production\") ? (job) => checkRecursiveUpdates(seen, job) : NOOP;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && !(job.flags & 8)) {\n        if (!!(process.env.NODE_ENV !== \"production\") && check(job)) {\n          continue;\n        }\n        if (job.flags & 4) {\n          job.flags &= ~1;\n        }\n        callWithErrorHandling(\n          job,\n          null,\n          ErrorCodes.SCHEDULER\n        );\n        if (!(job.flags & 4)) {\n          job.flags &= ~1;\n        }\n      }\n    }\n  } finally {\n    for (; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job) {\n        job.flags &= ~1;\n      }\n    }\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  const count = seen.get(fn) || 0;\n  if (count > RECURSION_LIMIT) {\n    handleError(\n      `Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,\n      null,\n      ErrorCodes.APP_ERROR_HANDLER\n    );\n    return true;\n  }\n  seen.set(fn, count + 1);\n  return false;\n}\nfunction watchEffect(effect2, options) {\n  return doWatch(effect2, null, options);\n}\nfunction watchSyncEffect(effect2, options) {\n  return doWatch(\n    effect2,\n    null,\n    !!(process.env.NODE_ENV !== \"production\") ? extend({}, options, { flush: \"sync\" }) : { flush: \"sync\" }\n  );\n}\nfunction watch(source, cb, options) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isFunction(cb)) {\n    warn(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only supports \\`watch(source, cb, options?) signature.`\n    );\n  }\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, flush, once } = options;\n  if (!!(process.env.NODE_ENV !== \"production\") && !cb) {\n    if (immediate !== void 0) {\n      warn(\n        `watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (deep !== void 0) {\n      warn(\n        `watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (once !== void 0) {\n      warn(\n        `watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n  }\n  const baseWatchOptions = extend({}, options);\n  if (!!(process.env.NODE_ENV !== \"production\")) baseWatchOptions.onWarn = warn;\n  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, null, type, args);\n  let isPre = false;\n  if (flush !== \"sync\") {\n    isPre = true;\n    baseWatchOptions.scheduler = (job, isFirstRun) => {\n      if (isFirstRun) {\n        job();\n      } else {\n        queueJob(job);\n      }\n    };\n  }\n  baseWatchOptions.augmentJob = (job) => {\n    if (cb) {\n      job.flags |= SchedulerJobFlags.ALLOW_RECURSE;\n    }\n    if (isPre) {\n      job.flags |= SchedulerJobFlags.PRE;\n    }\n  };\n  const watchHandle = watch$1(source, cb, baseWatchOptions);\n  return watchHandle;\n}\nexport {\n  ARRAY_ITERATE_KEY,\n  EffectFlags,\n  EffectScope,\n  ITERATE_KEY,\n  MAP_KEY_ITERATE_KEY,\n  ReactiveEffect,\n  ReactiveFlags,\n  TrackOpTypes,\n  TriggerOpTypes,\n  WatchErrorCodes,\n  computed,\n  customRef,\n  effect,\n  effectScope,\n  enableTracking,\n  getCurrentScope,\n  getCurrentWatcher,\n  isProxy,\n  isReactive,\n  isReadonly,\n  isRef,\n  isShallow,\n  markRaw,\n  nextTick,\n  onEffectCleanup,\n  onScopeDispose,\n  onWatcherCleanup,\n  pauseTracking,\n  proxyRefs,\n  reactive,\n  reactiveReadArray,\n  readonly,\n  ref,\n  resetTracking,\n  shallowReactive,\n  shallowReadArray,\n  shallowReadonly,\n  shallowRef,\n  stop,\n  toRaw,\n  toReactive,\n  toReadonly,\n  toRef,\n  toRefs,\n  toValue,\n  track,\n  traverse,\n  trigger,\n  triggerRef,\n  unref,\n  watch,\n  watchEffect,\n  watchSyncEffect\n};\n","import { getCurrentScope as K, onScopeDispose as F, effectScope as Q, shallowRef as g, computed as h, shallowReactive as $, toValue as s, watchEffect as C, watch as D, ref as x, toRaw as ee, isRef as te } from \"@reactive-vscode/reactivity\";\nexport * from \"@reactive-vscode/reactivity\";\nimport { workspace as S, commands as I, window as v, debug as H, extensions as O, comments as ne, env as p, EventEmitter as U, tasks as k, Uri as ie, languages as ae, ColorThemeKind as B, l10n as z } from \"vscode\";\nfunction re(e) {\n  return K() ? (F(e), !0) : !1;\n}\nfunction q(e, t) {\n  const n = /* @__PURE__ */ new Map();\n  return (...i) => {\n    const a = t(...i);\n    let u = n.get(a);\n    return u ? u.refCount++ : (u = {\n      data: e(...i),\n      refCount: 1\n    }, n.set(a, u)), re(() => {\n      --u.refCount === 0 && n.delete(a);\n    }), u.data;\n  };\n}\nfunction w(e) {\n  let t;\n  return () => t !== void 0 ? t : t = Q(!0).run(e);\n}\nconst Y = [];\nfunction De(e) {\n  Y.push(e);\n}\nconst R = g(null), M = Q();\nfunction Te(e) {\n  return {\n    activate: (t) => (R.value = t, M.run(() => (G.map((n) => n(t)), e(t)))),\n    deactivate: () => {\n      Y.map((t) => t()), M.stop();\n    }\n  };\n}\nconst G = [];\nfunction J(e) {\n  R.value ? e(R.value) : G.push(e);\n}\nfunction se(e, t, n) {\n  const i = !e, a = S.getConfiguration(i ? void 0 : e, n);\n  function u(c, o) {\n    const d = g(o), b = h({\n      get: () => d.value,\n      set: (f) => {\n        d.value = f, a.update(c, f);\n      }\n    });\n    return b.update = async (f, m, T) => {\n      await a.update(c, f, m, T), b.value = f;\n    }, b.set = (f) => {\n      d.value = f;\n    }, b;\n  }\n  const r = Object.fromEntries(\n    Object.keys(t).map((c) => [c, u(c, a.get(c))])\n  );\n  return J(() => {\n    l(S.onDidChangeConfiguration(\n      i ? (c) => {\n        const o = S.getConfiguration();\n        for (const d in t)\n          c.affectsConfiguration(d) && r[d].set(o.get(d));\n      } : (c) => {\n        if (!c.affectsConfiguration(e))\n          return;\n        const o = S.getConfiguration(e);\n        for (const d in t)\n          c.affectsConfiguration(`${e}.${d}`) && r[d].set(o.get(d));\n      }\n    ));\n  }), r;\n}\nfunction Se(e, t, n) {\n  const i = se(e, t, n), a = {}, u = $({\n    $update(r, c, o, d) {\n      return i[r].update(c, o, d);\n    },\n    $set(r, c) {\n      return i[r].set(c);\n    }\n  });\n  for (const r in t) {\n    const c = r.split(\".\");\n    let o = \"\", d = a, b = u;\n    for (const m of c.slice(0, -1)) {\n      o = o ? `${o}.${m}` : m;\n      const T = d = d[m] || (d[m] = {});\n      if (b[m])\n        b = b[m];\n      else {\n        const N = $({});\n        Object.defineProperty(b, m, {\n          enumerable: !0,\n          get() {\n            return N;\n          },\n          set(_) {\n            function j(P, W, y) {\n              if (P)\n                for (const V in P)\n                  j(P[V], W ? `${W}.${V}` : V, y == null ? void 0 : y[V]);\n              else\n                i[W].value = y;\n            }\n            j(T, o, _);\n          }\n        }), b = N;\n      }\n    }\n    const f = c[c.length - 1];\n    d[f] = null, Object.defineProperty(b, f, {\n      enumerable: !0,\n      get() {\n        return i[r].value;\n      },\n      set(m) {\n        i[r].value = m;\n      }\n    });\n  }\n  return u;\n}\nfunction xe(e, t) {\n  const n = g(null), i = [], a = (u) => (...r) => n.value ? n.value[u](...r) : (i.push([u, r]), null);\n  return J(() => {\n    n.value = ge(e, t);\n    for (const [u, r] of i)\n      n.value[u](...r);\n  }), {\n    logger: n,\n    outputChannel: h(() => {\n      var u;\n      return (u = n.value) == null ? void 0 : u.outputChannel;\n    }),\n    info: a(\"info\"),\n    warn: a(\"warn\"),\n    error: a(\"error\"),\n    append: a(\"append\"),\n    appendLine: a(\"appendLine\"),\n    replace: a(\"replace\"),\n    clear: a(\"clear\"),\n    show: a(\"show\"),\n    hide: a(\"hide\")\n  };\n}\nfunction Ee(e, ...t) {\n  return I.executeCommand(e, ...t);\n}\nfunction ue(e, t = !1) {\n  const n = R.value;\n  if (!n && !t)\n    throw new Error(\"Cannot get absolute path because the extension is not activated yet\");\n  return n == null ? void 0 : n.asAbsolutePath(e);\n}\nfunction pe(e, t = !1) {\n  return h(() => ue(s(e), t));\n}\nfunction l(e) {\n  return (K() ?? M).cleanups.push(e.dispose.bind(e)), e;\n}\nconst ce = w(() => {\n  const e = g(v.activeColorTheme);\n  return l(v.onDidChangeActiveColorTheme((t) => {\n    e.value = t;\n  })), e;\n}), ke = w(() => {\n  const e = g(H.activeDebugSession);\n  return l(H.onDidChangeActiveDebugSession((t) => {\n    e.value = t;\n  })), h(() => e.value);\n}), oe = w(() => {\n  const e = g(v.activeTextEditor);\n  return l(v.onDidChangeActiveTextEditor((t) => {\n    e.value = t;\n  })), e;\n});\nfunction le(e) {\n  var n;\n  const t = g((n = s(e)) == null ? void 0 : n.getText());\n  return C(() => {\n    var i;\n    t.value = (i = s(e)) == null ? void 0 : i.getText();\n  }), l(S.onDidChangeTextDocument((i) => {\n    i.document === s(e) && (t.value = i.document.getText());\n  })), t;\n}\nfunction de(e, t, n, i = {}) {\n  const {\n    updateOn: a = [\"effect\", \"documentChanged\"]\n  } = i, u = h(\n    (o) => {\n      o == null || o.dispose();\n      const d = s(t);\n      return \"key\" in d ? d : l(v.createTextEditorDecorationType(d));\n    }\n  ), r = async () => {\n    const o = s(e);\n    o && o.setDecorations(\n      u.value,\n      typeof n == \"function\" ? await n(o) : s(n)\n    );\n  }, c = a.includes(\"documentChanged\") ? le(() => {\n    var o;\n    return (o = s(e)) == null ? void 0 : o.document;\n  }) : null;\n  return a.includes(\"effect\") ? C(async () => {\n    c == null || c.value, await r();\n  }) : c && D(c, r), {\n    /**\n     * Manually trigger the decoration update.\n     */\n    update: r\n  };\n}\nfunction Re(e, t) {\n  const n = oe();\n  de(n, e, t);\n}\nconst ye = w(() => {\n  const e = g(v.activeNotebookEditor);\n  return l(v.onDidChangeActiveNotebookEditor((t) => {\n    e.value = t;\n  })), e;\n}), Ve = w(() => {\n  const e = g(v.activeTerminal);\n  return l(v.onDidChangeActiveTerminal((t) => {\n    e.value = t;\n  })), e;\n}), Ae = w(() => {\n  const e = g(O.all);\n  return l(O.onDidChange(() => {\n    e.value = O.all;\n  })), h(() => e.value);\n});\nfunction fe(e, t) {\n  l(I.registerCommand(e, t));\n}\nfunction Ie(e) {\n  for (const [t, n] of Object.entries(e))\n    n && fe(t, n);\n}\nfunction Pe(e, t) {\n  return l(ne.createCommentController(e, t));\n}\nfunction X(e) {\n  var n;\n  const t = g((n = s(e)) == null ? void 0 : n.state);\n  return D(e, () => {\n    var i;\n    t.value = (i = s(e)) == null ? void 0 : i.state;\n  }), l(v.onDidChangeTerminalState((i) => {\n    i === s(e) && (t.value = i.state);\n  })), h(() => t.value);\n}\nfunction We(...e) {\n  const t = x(null);\n  function n() {\n    return !!t.value && t.value.exitStatus == null;\n  }\n  function i() {\n    return n() ? t.value : t.value = v.createTerminal(...e);\n  }\n  function a(c) {\n    i().sendText(c);\n  }\n  function u() {\n    i().show();\n  }\n  function r() {\n    n() && (t.value.sendText(\"\u0003\"), t.value.dispose(), t.value = null);\n  }\n  return F(r), {\n    terminal: t,\n    getIsActive: n,\n    show: u,\n    sendText: a,\n    close: r,\n    state: X(t)\n  };\n}\nconst Oe = w(() => {\n  const e = g(p.shell);\n  return l(p.onDidChangeShell((t) => {\n    e.value = t;\n  })), h(() => e.value);\n});\nfunction E(e, t) {\n  const n = (i, a, u) => {\n    l(e(i, a, u));\n  };\n  return t == null || t.forEach((i) => n(i)), n;\n}\nfunction A(e, t = []) {\n  const n = Array.isArray(e) ? e : t ?? [], i = l(Array.isArray(e) || e == null ? new U() : e), a = E(i.event, n);\n  for (const u of n)\n    a(u);\n  return {\n    event: i.event,\n    fire: i.fire.bind(i),\n    addListener: a\n  };\n}\nasync function $e(e) {\n  const t = R.value.secrets, n = x(await t.get(e));\n  return n.set = async (i) => {\n    n.value = i, await t.store(e, i);\n  }, n.remove = async () => {\n    n.value = void 0, await t.delete(e);\n  }, l(t.onDidChange(async (i) => {\n    i.key === e && (n.value = await t.get(e));\n  })), D(n, (i) => {\n    i === void 0 ? t.delete(e) : t.store(e, i);\n  }), n;\n}\nfunction Me(e) {\n  return h(() => k.fetchTasks(s(e)));\n}\nfunction Fe(e) {\n  return h(() => ie.file(s(e)));\n}\nfunction Le(e, t) {\n  const n = new U(), i = g();\n  C(() => {\n    i.value && n.fire(), i.value = s(t);\n  }), l(ae.registerFoldingRangeProvider(\n    e,\n    {\n      onDidChangeFoldingRanges: n.event,\n      provideFoldingRanges(a, u, r) {\n        var c;\n        return (c = i.value) == null ? void 0 : c.call(i, a, u, r);\n      }\n    }\n  ));\n}\nfunction Ne(e, t, n, i) {\n  const a = $(/* @__PURE__ */ new Map()), u = A(), r = A(), c = A(), o = h(() => {\n    const f = s(e);\n    return Array.isArray(f) ? f : f instanceof Set ? Array.from(f) : [f];\n  });\n  function d() {\n    const f = o.value;\n    for (const [m, T] of a)\n      f.includes(m) || (T.dispose(), a.delete(m));\n    for (const m of f)\n      if (!a.has(m)) {\n        const T = S.createFileSystemWatcher(\n          m,\n          s(t) || !1,\n          s(n) || !1,\n          s(i) || !1\n        );\n        T.onDidCreate(u.fire), T.onDidChange(r.fire), T.onDidDelete(c.fire), a.set(m, T);\n      }\n  }\n  function b() {\n    for (const f of a.values())\n      f.dispose();\n    a.clear();\n  }\n  return d(), D(o, d), D(\n    () => [\n      s(t),\n      s(n),\n      s(i)\n    ],\n    () => {\n      b(), d();\n    }\n  ), F(b), {\n    watchers: a,\n    onDidCreate: u.event,\n    onDidChange: r.event,\n    onDidDelete: c.event\n  };\n}\nconst je = w(() => {\n  const e = ce();\n  return h(() => e.value.kind === B.Dark || e.value.kind === B.HighContrast);\n}), He = w(() => {\n  const e = g(p.isTelemetryEnabled);\n  return l(p.onDidChangeTelemetryEnabled((t) => {\n    e.value = t;\n  })), h(() => e.value);\n});\nfunction Be(e, ...t) {\n  return h(() => typeof t[0] == \"object\" ? z.t(s(e), ee(t[0])) : z.t(s(e), ...t.map(s)));\n}\nfunction ve(e, t) {\n  return l(v.createOutputChannel(e, t));\n}\nfunction ze(e) {\n  const t = /* @__PURE__ */ new Date(), n = String(t.getFullYear()).padStart(4, \"0\"), i = String(t.getMonth() + 1).padStart(2, \"0\"), a = String(t.getDate()).padStart(2, \"0\"), u = String(t.getHours()).padStart(2, \"0\"), r = String(t.getMinutes()).padStart(2, \"0\"), c = String(t.getSeconds()).padStart(2, \"0\"), o = String(t.getMilliseconds()).padStart(3, \"0\");\n  return `${n}-${i}-${a} ${u}:${r}:${c}.${o} [${e}] `;\n}\nfunction ge(e, t = {}) {\n  const n = t.outputChannel ?? ve(e), i = (a) => (...u) => {\n    var r;\n    n.appendLine((((r = t.getPrefix) == null ? void 0 : r.call(t, a)) ?? \"\") + u.join(\" \"));\n  };\n  return {\n    outputChannel: n,\n    createLoggerFunc: i,\n    info: i(\"INFO\"),\n    warn: i(\"WARN\"),\n    error: i(\"ERROR\"),\n    append: n.append.bind(n),\n    appendLine: n.appendLine.bind(n),\n    replace: n.replace.bind(n),\n    clear: n.clear.bind(n),\n    show: n.show.bind(n),\n    hide: n.hide.bind(n)\n  };\n}\nconst Ke = w(() => {\n  const e = g(p.logLevel);\n  return l(p.onDidChangeLogLevel((t) => {\n    e.value = t;\n  })), h(() => e.value);\n});\nfunction he(e) {\n  var n;\n  const t = g(((n = s(e)) == null ? void 0 : n.selections) ?? []);\n  return D(e, () => {\n    var i;\n    t.value = ((i = s(e)) == null ? void 0 : i.selections) ?? [];\n  }), l(v.onDidChangeNotebookEditorSelection((i) => {\n    i.notebookEditor === s(e) && (t.value = i.selections);\n  })), h({\n    get() {\n      return t.value;\n    },\n    set(i) {\n      t.value = i;\n      const a = s(e);\n      a && (a.selections = i);\n    }\n  });\n}\nfunction Qe(e) {\n  const t = he(e);\n  return h({\n    get() {\n      return t.value[0];\n    },\n    set(n) {\n      t.value = t.value.toSpliced(0, 1, n);\n    }\n  });\n}\nfunction Ue(e) {\n  var n;\n  const t = g(((n = s(e)) == null ? void 0 : n.visibleRanges) ?? []);\n  return D(e, () => {\n    var i;\n    t.value = ((i = s(e)) == null ? void 0 : i.visibleRanges) ?? [];\n  }), l(v.onDidChangeNotebookEditorVisibleRanges((i) => {\n    i.notebookEditor === s(e) && (t.value = i.visibleRanges);\n  })), h(() => t.value);\n}\nconst qe = w(() => {\n  const e = g(v.terminals);\n  function t() {\n    e.value = v.terminals;\n  }\n  return l(v.onDidOpenTerminal(t)), l(v.onDidCloseTerminal(t)), e;\n});\nfunction Ye(e = {}) {\n  const t = l(v.createQuickPick()), n = E(t.onDidChangeActive), i = E(t.onDidChangeSelection), a = E(t.onDidAccept), u = E(t.onDidHide), r = E(t.onDidTriggerButton), c = E(t.onDidChangeValue);\n  [\n    \"items\",\n    \"buttons\",\n    \"title\",\n    \"step\",\n    \"totalSteps\",\n    \"enabled\",\n    \"busy\",\n    \"ignoreFocusOut\",\n    \"placeholder\",\n    \"canSelectMany\",\n    \"matchOnDescription\",\n    \"matchOnDetail\",\n    \"keepScrollPosition\"\n  ].forEach((f) => {\n    e[f] && C(() => t[f] = s(e[f]));\n  }), e.value && (t.value = e.value);\n  const o = g(t.value);\n  c((f) => o.value = f), e.activeItems && (t.activeItems = e.activeItems);\n  const d = g(t.activeItems);\n  n((f) => d.value = f), e.selectedItems && (t.selectedItems = e.selectedItems);\n  const b = g(t.selectedItems);\n  return i((f) => b.value = f), {\n    ...t,\n    onDidChangeActive: n,\n    onDidChangeSelection: i,\n    onDidAccept: a,\n    onDidHide: u,\n    onDidTriggerButton: r,\n    onDidChangeValue: c,\n    value: o,\n    activeItems: d,\n    selectedItems: b\n  };\n}\nfunction Ge(e) {\n  const t = l(e.id ? v.createStatusBarItem(e.id, e.alignment, e.priority) : v.createStatusBarItem(e.alignment, e.priority));\n  function n(i) {\n    const a = e[i];\n    a != null && C(() => t[i] = s(a));\n  }\n  return [\n    \"name\",\n    \"text\",\n    \"tooltip\",\n    \"color\",\n    \"backgroundColor\",\n    \"command\",\n    \"accessibilityInformation\"\n  ].forEach(n), e.visible != null && C(() => {\n    s(e.visible) ? t.show() : t.hide();\n  }), t;\n}\nconst Je = w(() => {\n  const e = g(k.taskExecutions);\n  function t() {\n    e.value = k.taskExecutions;\n  }\n  return l(k.onDidStartTask(t)), l(k.onDidEndTask(t)), h(() => e.value);\n});\nfunction Xe(...e) {\n  const t = l(v.createTerminal(...e));\n  return {\n    terminal: t,\n    get name() {\n      return t.name;\n    },\n    get processId() {\n      return t.processId;\n    },\n    get creationOptions() {\n      return t.creationOptions;\n    },\n    get exitStatus() {\n      return t.exitStatus;\n    },\n    get shellIntegration() {\n      return t.shellIntegration;\n    },\n    sendText: t.sendText.bind(t),\n    show: t.show.bind(t),\n    hide: t.hide.bind(t),\n    state: X(t)\n  };\n}\nfunction me(e, t) {\n  l(I.registerTextEditorCommand(e, t));\n}\nfunction Ze(e) {\n  for (const [t, n] of Object.entries(e))\n    me(t, n);\n}\nfunction be(e, t) {\n  var i;\n  const n = g(((i = s(e)) == null ? void 0 : i.selections) ?? []);\n  return D(e, () => {\n    var a;\n    n.value = ((a = s(e)) == null ? void 0 : a.selections) ?? [];\n  }), l(v.onDidChangeTextEditorSelection((a) => {\n    const u = s(e), r = s(t);\n    a.textEditor === u && (!r || r.includes(a.kind)) && (n.value = a.selections);\n  })), h({\n    get() {\n      return n.value;\n    },\n    set(a) {\n      n.value = a;\n      const u = s(e);\n      u && (u.selections = a);\n    }\n  });\n}\nfunction _e(e, t) {\n  const n = be(e, t);\n  return h({\n    get() {\n      return n.value[0];\n    },\n    set(i) {\n      n.value = n.value.toSpliced(0, 1, i);\n    }\n  });\n}\nfunction et(e) {\n  var n;\n  const t = g((n = s(e)) == null ? void 0 : n.viewColumn);\n  return D(e, () => {\n    var i;\n    t.value = (i = s(e)) == null ? void 0 : i.viewColumn;\n  }), l(v.onDidChangeTextEditorViewColumn((i) => {\n    i.textEditor === s(e) && (t.value = i.viewColumn);\n  })), h(() => t.value);\n}\nfunction tt(e) {\n  var n;\n  const t = g(((n = s(e)) == null ? void 0 : n.visibleRanges) ?? []);\n  return D(e, () => {\n    var i;\n    t.value = ((i = s(e)) == null ? void 0 : i.visibleRanges) ?? [];\n  }), l(v.onDidChangeTextEditorVisibleRanges((i) => {\n    i.textEditor === s(e) && (t.value = i.visibleRanges);\n  })), h(() => t.value);\n}\nfunction Z(e, t) {\n  C(() => {\n    const n = s(e);\n    n && (n.badge = s(t));\n  });\n}\nfunction L(e, t) {\n  C(() => {\n    const n = s(e);\n    n && (n.title = s(t));\n  });\n}\nconst nt = q(\n  (e, t, n) => {\n    const i = A();\n    D(t, () => i.fire()), n != null && n.watchSource && D(n.watchSource, () => i.fire());\n    const a = /* @__PURE__ */ new WeakMap(), u = l(v.createTreeView(e, {\n      ...n,\n      treeDataProvider: {\n        ...n,\n        onDidChangeTreeData: i.event,\n        getTreeItem(r) {\n          return r.treeItem;\n        },\n        getChildren(r) {\n          var c;\n          return r ? ((c = r.children) == null || c.forEach((o) => a.set(o, r)), r.children) : s(t);\n        },\n        getParent(r) {\n          return a.get(r);\n        }\n      }\n    }));\n    return n != null && n.title && L(u, n.title), n != null && n.badge && Z(u, n.badge), u;\n  },\n  (e) => e\n);\nfunction it(e) {\n  var i;\n  const t = x((i = s(e)) == null ? void 0 : i.visible);\n  function n() {\n    var a;\n    t.value = (a = s(e)) == null ? void 0 : a.visible;\n  }\n  return C((a) => {\n    const u = s(e);\n    if (u) {\n      const r = u.onDidChangeVisibility(n);\n      a(() => r.dispose());\n    }\n  }), C(n), h(() => !!t.value);\n}\nconst at = w(() => {\n  const e = g(v.visibleNotebookEditors);\n  return l(v.onDidChangeVisibleNotebookEditors((t) => {\n    e.value = t;\n  })), e;\n}), rt = w(() => {\n  const e = g(v.visibleTextEditors);\n  return l(v.onDidChangeVisibleTextEditors((t) => {\n    e.value = t;\n  })), e;\n});\nfunction st(e, t, n = !0) {\n  const i = te(t) ? t : typeof t == \"function\" ? h(t) : x(t);\n  return C(() => {\n    s(n) && I.executeCommand(\"setContext\", e, i.value);\n  }), i;\n}\nfunction ut(e, t, n, i, a) {\n  const u = g(), r = l(v.createWebviewPanel(\n    e,\n    s(t),\n    i,\n    {\n      enableFindWidget: a == null ? void 0 : a.enableFindWidget,\n      retainContextWhenHidden: a == null ? void 0 : a.retainContextWhenHidden,\n      ...s(a == null ? void 0 : a.webviewOptions)\n    }\n  ));\n  a != null && a.onDidReceiveMessage && r.webview.onDidReceiveMessage(a.onDidReceiveMessage);\n  const c = x(0);\n  function o() {\n    c.value++;\n  }\n  if (C(() => {\n    r.webview.html = `${s(n)}<!--${c.value}-->`;\n  }), a != null && a.webviewOptions) {\n    const m = a.webviewOptions;\n    C(() => {\n      r.webview.options = s(m);\n    });\n  }\n  L(r, t);\n  function d(m) {\n    return r.webview.postMessage(m);\n  }\n  const b = x(r.active), f = x(r.visible);\n  return l(r.onDidChangeViewState(() => {\n    b.value = r.active, f.value = r.visible;\n  })), { panel: r, context: u, active: b, visible: f, postMessage: d, forceRefresh: o };\n}\nconst ct = q(\n  (e, t, n) => {\n    const i = g(), a = g();\n    l(v.registerWebviewViewProvider(\n      e,\n      {\n        resolveWebviewView(o, d) {\n          i.value = o, a.value = d, n != null && n.onDidReceiveMessage && o.webview.onDidReceiveMessage(n.onDidReceiveMessage);\n        }\n      },\n      {\n        webviewOptions: {\n          retainContextWhenHidden: n == null ? void 0 : n.retainContextWhenHidden\n        }\n      }\n    ));\n    const u = x(0);\n    function r() {\n      u.value++;\n    }\n    if (C(() => {\n      i.value && (i.value.webview.html = `${s(t)}<!--${u.value}-->`);\n    }), n != null && n.webviewOptions) {\n      const o = n.webviewOptions;\n      C(() => {\n        i.value && (i.value.webview.options = s(o));\n      });\n    }\n    n != null && n.title && L(i, n.title), n != null && n.badge && Z(i, n.badge);\n    function c(o) {\n      var d;\n      return (d = i.value) == null ? void 0 : d.webview.postMessage(o);\n    }\n    return { view: i, context: a, postMessage: c, forceRefresh: r };\n  },\n  (e) => e\n), ot = w(() => {\n  const e = g(v.state);\n  return l(v.onDidChangeWindowState((t) => {\n    e.value = t;\n  })), {\n    focused: h(() => e.value.focused),\n    active: h(() => e.value.active)\n  };\n}), lt = w(() => {\n  const e = g(S.workspaceFolders);\n  return l(S.onDidChangeWorkspaceFolders(() => {\n    e.value = S.workspaceFolders;\n  })), h(() => e.value);\n});\nexport {\n  G as activateCbs,\n  q as createKeyedComposable,\n  w as createSingletonComposable,\n  Y as deactivateCbs,\n  Se as defineConfigObject,\n  se as defineConfigs,\n  Te as defineExtension,\n  xe as defineLogger,\n  Ee as executeCommand,\n  R as extensionContext,\n  M as extensionScope,\n  ze as getDefaultLoggerPrefix,\n  J as onActivate,\n  De as onDeactivate,\n  re as tryOnScopeDispose,\n  pe as useAbsolutePath,\n  ce as useActiveColorTheme,\n  ke as useActiveDebugSession,\n  Re as useActiveEditorDecorations,\n  ye as useActiveNotebookEditor,\n  Ve as useActiveTerminal,\n  oe as useActiveTextEditor,\n  Ae as useAllExtensions,\n  fe as useCommand,\n  Ie as useCommands,\n  Pe as useCommentController,\n  We as useControlledTerminal,\n  Oe as useDefaultShell,\n  l as useDisposable,\n  le as useDocumentText,\n  de as useEditorDecorations,\n  E as useEvent,\n  A as useEventEmitter,\n  $e as useExtensionSecret,\n  Me as useFetchTasks,\n  Fe as useFileUri,\n  Le as useFoldingRangeProvider,\n  Ne as useFsWatcher,\n  je as useIsDarkTheme,\n  He as useIsTelemetryEnabled,\n  Be as useL10nText,\n  Ke as useLogLevel,\n  ge as useLogger,\n  Qe as useNotebookEditorSelection,\n  he as useNotebookEditorSelections,\n  Ue as useNotebookEditorVisibleRanges,\n  qe as useOpenedTerminals,\n  ve as useOutputChannel,\n  Ye as useQuickPick,\n  Ge as useStatusBarItem,\n  Je as useTaskExecutions,\n  Xe as useTerminal,\n  X as useTerminalState,\n  me as useTextEditorCommand,\n  Ze as useTextEditorCommands,\n  _e as useTextEditorSelection,\n  be as useTextEditorSelections,\n  et as useTextEditorViewColumn,\n  tt as useTextEditorVisibleRanges,\n  nt as useTreeView,\n  Z as useViewBadge,\n  L as useViewTitle,\n  it as useViewVisibility,\n  at as useVisibleNotebookEditors,\n  rt as useVisibleTextEditors,\n  st as useVscodeContext,\n  ut as useWebviewPanel,\n  ct as useWebviewView,\n  ot as useWindowState,\n  lt as useWorkspaceFolders\n};\n","export const clockIconName = '$(clock)'\r\n","import { ref, useEvent, useLogger, watchEffect } from 'reactive-vscode'\r\nimport { debug, tasks, window, workspace } from 'vscode'\r\n\r\nexport const onDidChangeTextEditorSelection = useEvent(window.onDidChangeTextEditorSelection)\r\nexport const onDidChangeActiveTextEditor = useEvent(window.onDidChangeActiveTextEditor)\r\n\r\nexport const onDidSaveTextDocument = useEvent(workspace.onDidSaveTextDocument)\r\n\r\nexport const onDidStartTask = useEvent(tasks.onDidStartTask)\r\nexport const onDidEndTask = useEvent(tasks.onDidEndTask)\r\nexport const onDidChangeActiveDebugSession = useEvent(debug.onDidChangeActiveDebugSession)\r\nexport const onDidChangeBreakpoints = useEvent(debug.onDidChangeBreakpoints)\r\nexport const onDidStartDebugSession = useEvent(debug.onDidStartDebugSession)\r\nexport const onDidTerminateDebugSession = useEvent(debug.onDidTerminateDebugSession)\r\n\r\ninterface OnEventParams {\r\n  eventName: string\r\n  duringMs: number\r\n}\r\n\r\nexport function useOnEvent(onEvent: (params: OnEventParams) => void, debounceMs: number = 100) {\r\n  const eventName = ref('')\r\n  const duringMs = ref(0)\r\n  const setTimeoutId = ref<NodeJS.Timeout>()\r\n\r\n  const logger = useLogger('CodeBeat Event')\r\n\r\n  onDidChangeActiveTextEditor((e) => {\r\n    logger.error(`The file name of active text is ${e?.document.fileName}`)\r\n    eventName.value = 'onDidChangeActiveTextEditor'\r\n  })\r\n  onDidChangeTextEditorSelection(() => eventName.value = 'onDidChangeTextEditorSelection')\r\n  onDidSaveTextDocument(() => eventName.value = 'onDidSaveTextDocument')\r\n\r\n  setInterval(() => duringMs.value += debounceMs, debounceMs)\r\n\r\n  watchEffect(() => {\r\n    logger.info(`The event name is ${eventName.value}`)\r\n  })\r\n\r\n  watchEffect(() => {\r\n    if (!eventName.value)\r\n      return\r\n    clearTimeout(setTimeoutId.value)\r\n    setTimeoutId.value = setTimeout(() => {\r\n      onEvent({\r\n        eventName: eventName.value,\r\n        duringMs: duringMs.value,\r\n      })\r\n    }, debounceMs)\r\n  })\r\n}\r\n","import { useLogger } from 'reactive-vscode'\r\n\r\nexport const logger = useLogger('CodeBeat')\r\n\r\n/**\r\n * Format milliseconds to time string\r\n * @param ms - milliseconds\r\n * @returns formatted string:\r\n *   - \"0 min\" if less than 1 minute\r\n *   - \"x min(s)\" if less than 1 hour\r\n *   - \"x hrs y mins\" if 1 hour or more\r\n */\r\nexport function formatMilliseconds(ms: number): string {\r\n  if (ms < 0)\r\n    return '0 min'\r\n\r\n  const hours = Math.floor(ms / 3_600_000)\r\n  const minutes = Math.floor((ms % 3_600_000) / 60_000)\r\n\r\n  if (hours > 0) {\r\n    return `${hours} hr${hours > 1 ? 's' : ''} ${minutes} min${minutes !== 1 ? 's' : ''}`\r\n  }\r\n  return `${minutes} min${minutes !== 1 ? 's' : ''}`\r\n}\r\n"],"mappings":"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","names":["l","l","l","v","v","v","v","H","v","O","p","U","B","p","v","_a","p","v","v","k","v","v","v","S","import_vscode","import_vscode","logger"]}